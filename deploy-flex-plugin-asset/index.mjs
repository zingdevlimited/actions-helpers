import { randomBytes } from "crypto";
import {
  appendFileSync,
  readdirSync,
  existsSync,
  statSync,
  readFileSync,
} from "fs";
import path from "path";
import { exit } from "process";
const {
  INPUT_FILE_PATH,
  INPUT_PLUGIN_NAME,
  INPUT_PLUGIN_VERSION,
  INPUT_TWILIO_API_KEY,
  INPUT_TWILIO_API_SECRET,
  INPUT_ALLOW_VERSION_OVERWRITE,
  GITHUB_OUTPUT,
  GITHUB_STEP_SUMMARY,
} = process.env;

if (!INPUT_FILE_PATH?.trim()) {
  throw new Error("Missing Input FILE_PATH");
}
if (!INPUT_PLUGIN_NAME?.trim()) {
  throw new Error("Missing Input PLUGIN_NAME");
}
if (!INPUT_PLUGIN_VERSION?.trim()) {
  throw new Error("Missing Input PLUGIN_VERSION");
}
if (!INPUT_TWILIO_API_KEY?.trim()) {
  throw new Error("Missing Input TWILIO_API_KEY");
}
if (!INPUT_TWILIO_API_SECRET?.trim()) {
  throw new Error("Missing Input TWILIO_API_SECRET");
}

if (!existsSync(INPUT_FILE_PATH)) {
  throw new Error(
    `Path '${INPUT_FILE_PATH}' does not exist. Are you missing a checkout?`
  );
}

const MAX_RETRY_COUNT = 3;
const BASE_DELAY_MS = 2000;
/**
 * @typedef response
 * @property {object} body
 * @property {number} status
 * @property {boolean} ok
 *
 * @param {string} url
 * @param {"GET" | "POST" | "DELETE"} method
 * @param {URLSearchParams | undefined} bodyParams
 * @param {FormData | undefined} formData
 * @param {number} retryNumber
 * @returns {Promise<response>}
 */
const asyncTwilioRequest = async (
  url,
  method,
  bodyParams = undefined,
  formData = undefined,
  retryNumber = 0
) => {
  try {
    console.log(`::debug::Request: ${method} ${url}`);
    const headers = {
      Authorization:
        "Basic " +
        Buffer.from(
          `${INPUT_TWILIO_API_KEY}:${INPUT_TWILIO_API_SECRET}`
        ).toString("base64"),
    };

    let body;
    if (bodyParams) {
      const undefinedParams = [];
      for (const [key, value] of bodyParams.entries()) {
        if (value === "undefined") {
          undefinedParams.push(key);
        }
      }
      for (const key of undefinedParams) {
        bodyParams.delete(key);
      }
      body = bodyParams.toString();
    }
    if (formData) {
      body = formData;
    }

    if (method === "POST" && bodyParams && body) {
      headers["Content-Type"] = "application/x-www-form-urlencoded";
      headers["Content-Length"] = Buffer.byteLength(
        /** @type {string} */ (body)
      );
    }
    const req = await fetch(url, { method, headers, body });

    if (req.status === 429) {
      if (retryNumber >= MAX_RETRY_COUNT) {
        throw new Error("Exceeded retry attempts after 429 errors");
      }
      const retryDelay = BASE_DELAY_MS * 2 ** retryNumber;
      console.log(`::debug::Rate-limit hit, retrying in ${retryDelay} ms...`);
      await new Promise((resolve) => setTimeout(resolve, retryDelay));
      return asyncTwilioRequest(
        url,
        method,
        bodyParams,
        formData,
        retryNumber + 1
      );
    }

    console.log(`::debug::Status: ${req.status} ${req.statusText}`);

    const ok = req.status >= 200 && req.status < 300;
    if (!ok) {
      throw { message: await req.text(), status: req.status };
    }

    let responseBody;
    if (
      req.headers.get("Content-Type")?.startsWith("application/json") &&
      req.status !== 204
    ) {
      responseBody = await req.json();
    } else {
      responseBody = {};
    }

    return {
      body: responseBody,
      status: req.status,
      ok,
    };
  } catch (err) {
    throw err;
    // return { body: undefined, status: 500, ok: false };
  }
};

const serverlessBaseUrl = "https://serverless.twilio.com/v1/Services";

let serviceResp;
try {
  serviceResp = await asyncTwilioRequest(`${serverlessBaseUrl}/default`, "GET");
} catch (err) {
  if (err.status === 404) {
    console.log("Plugin service not found. Creating new...");
    serviceResp = await asyncTwilioRequest(
      `${serverlessBaseUrl}`,
      "POST",
      new URLSearchParams({
        FriendlyName: "Flex Plugins Service (Autogenerated) - Do Not Delete",
        UniqueName: "default",
        IncludeCredentials: "true",
      })
    );
  } else {
    throw err;
  }
}

const serviceSid = serviceResp.body.sid;
console.log(`Service Sid: ${serviceSid}`);

const environmentListResp = await asyncTwilioRequest(
  `${serverlessBaseUrl}/${serviceSid}/Environments`,
  "GET"
);
/** @type {Array} */
const environmentList = environmentListResp.body.environments;
let environment = environmentList.find(
  (e) => e.unique_name === INPUT_PLUGIN_NAME
);

const randomSuffix = () =>
  randomBytes(64)
    .toString("base64")
    .replace(/[^a-z0-9]/gi, "")
    .toLowerCase()
    .slice(0, 7);

if (!environment) {
  console.log("Environment not found. Creating new...");

  const existingSuffixes = environmentList.map((e) => e.domain_suffix);
  let newSuffix = randomSuffix();

  while (existingSuffixes.includes(newSuffix)) {
    console.log("Suffix collision, regenerating suffix...");
    newSuffix = randomSuffix();
  }
  console.log(`Generated suffix ${newSuffix}`);

  const environmentRes = await asyncTwilioRequest(
    `${serverlessBaseUrl}/${serviceSid}/Environments`,
    "POST",
    new URLSearchParams({
      UniqueName: INPUT_PLUGIN_NAME,
      DomainSuffix: newSuffix,
    })
  );

  environment = environmentRes.body;
  console.log(
    `Created Environment ${INPUT_PLUGIN_NAME} with suffix ${newSuffix} (${environment.sid})`
  );
}

const environmentSid = environment.sid;
const environmentDomainName = environment.domain_name;
const assetPath = `${INPUT_PLUGIN_NAME}/${INPUT_PLUGIN_VERSION}/bundle.js`;
const assetUrl = `https://${environmentDomainName}/plugins/${assetPath}`;

const currentBuildSid = environment.build_sid;

let assetVersions = [];
if (currentBuildSid) {
  const buildResp = await asyncTwilioRequest(
    `${serverlessBaseUrl}/${serviceSid}/Builds/${currentBuildSid}`,
    "GET"
  );
  /** @type {Array} */
  const buildAssetVersions = buildResp.body.asset_versions;

  const assetVersionExists = buildAssetVersions.some((a) =>
    a.path.endsWith(assetPath)
  );
  if (assetVersionExists) {
    console.log(
      `::warning::There is already a deployed Asset Version for ${assetUrl}`
    );
    if (INPUT_ALLOW_VERSION_OVERWRITE === "true") {
      console.log(
        "Overwriting deployed bundle due to ALLOW_VERSION_OVERWRITE flag being enabled."
      );
    } else {
      console.error(
        "::error::Failing deployment due to existing Asset Version. Bump the version or set ALLOW_VERSION_OVERWRITE to true to proceed."
      );
      exit(1);
    }
  }

  assetVersions = buildAssetVersions
    .filter((a) => a.path.endsWith(".js") && !a.path.endsWith(assetPath))
    .map((a) => a.sid);
}

const listAssetsResp = await asyncTwilioRequest(
  `${serverlessBaseUrl}/${serviceSid}/Assets`,
  "GET"
);
/** @type {Array} */
const assetList = listAssetsResp.body.assets;
const assetFriendlyName = `${INPUT_PLUGIN_NAME}@${INPUT_PLUGIN_VERSION}`;

let assetResource = assetList.find(
  (a) => a.friendly_name === assetFriendlyName
);

if (!assetResource) {
  const newAssetResp = await asyncTwilioRequest(
    `${serverlessBaseUrl}/${serviceSid}/Assets`,
    "POST",
    new URLSearchParams({ FriendlyName: assetFriendlyName })
  );
  assetResource = newAssetResp.body;
}

const content = readFileSync(INPUT_FILE_PATH);

const formData = new FormData();
formData.set("Path", `plugins/${assetPath}`);
formData.set("Visibility", "protected");
formData.set(
  "Content",
  new Blob([content], { type: "application/javascript" })
);

const uploadRes = await asyncTwilioRequest(
  `https://serverless-upload.twilio.com/v1/Services/${serviceSid}/Assets/${assetResource.sid}/Versions`,
  "POST",
  undefined,
  formData
);

assetVersions.push(uploadRes.body.sid);

const buildParams = new URLSearchParams();
for (const assetVersion of assetVersions) {
  buildParams.append("AssetVersions", assetVersion);
}

const build = await asyncTwilioRequest(
  `${serverlessBaseUrl}/${serviceSid}/Builds`,
  "POST",
  buildParams
);
const buildSid = build.body.sid;
let buildStatus = "building";
console.log(`Starting Build ${buildSid}...`);

for (let i = 0; i < 10; i++) {
  await new Promise((resolve) => setTimeout(resolve, 5000));
  console.log(`[${(i + 1) * 5} seconds] Polling build status... `);

  const statusResponse = await asyncTwilioRequest(
    `${serverlessBaseUrl}/${serviceSid}/Builds/${buildSid}/Status`,
    "GET"
  );
  buildStatus = statusResponse.body.status;
  console.log(buildStatus);

  if (buildStatus === "completed") {
    break;
  } else if (buildStatus === "failed") {
    throw new Error(
      `Build ${buildSid} returned failed status. Full response: ${statusResponse.body}`
    );
  }
}

if (buildStatus !== "completed") {
  throw new Error(`Build ${buildSid} has timed out`);
}

console.log(`Build ${buildSid} has been completed`);

const deploymentResp = await asyncTwilioRequest(
  `${serverlessBaseUrl}/${serviceSid}/Environments/${environmentSid}/Deployments`,
  "POST",
  new URLSearchParams({
    BuildSid: buildSid,
  })
);

console.log(
  `âœ… Deployment ${deploymentResp.body.sid} created to Environment ${environmentSid}`
);

if (GITHUB_STEP_SUMMARY) {
  appendFileSync(
    GITHUB_STEP_SUMMARY,
    `## Deployed Plugin Bundle ${assetFriendlyName} to Assets\n`
  );
  appendFileSync(GITHUB_STEP_SUMMARY, `**Bundle URL**: ${assetUrl}\n\n`);
  appendFileSync(GITHUB_STEP_SUMMARY, `**Versions included in Build**:`);
  for (const assetVersion of assetVersions) {
    appendFileSync(GITHUB_STEP_SUMMARY, `- ${assetVersion}\n`);
  }
}

if (GITHUB_OUTPUT) {
  appendFileSync(GITHUB_OUTPUT, `DEPLOY_SID=${deploymentResp.body.sid}\n`);
  appendFileSync(GITHUB_OUTPUT, `ASSET_URL=${assetUrl}\n`);
}
