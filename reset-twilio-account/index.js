
const MAX_RETRY_COUNT = 3;
const BASE_DELAY_MS = 2000;

/**
 * @typedef response
 * @property {object} body
 * @property {number} status
 * @property {boolean} ok
 * 
 * @param {string} url 
 * @param {"GET" | "POST" | "DELETE"} method 
 * @param {URLSearchParams} bodyParams 
 * @param {number} retryNumber 
 * @returns {Promise<response>}
 */
const asyncTwilioRequest = async (url, method, bodyParams = undefined, retryNumber = 0) => {
  try {
    console.log(`::debug::Request: ${method} ${url}`);
    const headers = {
      "Authorization": "Basic " + Buffer.from(`${TWILIO_API_KEY}:${TWILIO_API_SECRET}`).toString("base64")
    };
    
    let body;
    if (bodyParams) {
      const undefinedParams = [];
      for (const [key, value] of bodyParams.entries()) {
        if (value === "undefined") {
          undefinedParams.push(key);
        }
      }
      for (const key of undefinedParams) {
        bodyParams.delete(key);
      }
      body = bodyParams.toString();
    }

    if (method === "POST") {
      headers["Content-Type"] = "application/x-www-form-urlencoded";
      headers["Content-Length"] = Buffer.byteLength(body);
    }

    const req = await fetch(url, { method, headers, body });

    if (req.status === 429) {
      if (retryNumber >= MAX_RETRY_COUNT) {
        throw new Error("Exceeded retry attempts after 429 errors");
      }
      const retryDelay = BASE_DELAY_MS * (2 ** retryNumber);
      console.log(`::debug::Rate-limit hit, retrying in ${retryDelay} ms...`)
      await new Promise((resolve) => setTimeout(resolve, retryDelay));
      return asyncTwilioRequest(url, method, bodyParams, retryNumber + 1);
    }

    console.log(`::debug::Status: ${req.status} ${req.statusText}`);

    const ok = req.status >= 200 && req.status < 300;
    if (!ok) {
      throw new Error(`Error Response: ${await req.text()}`);
    }

    let responseBody;
    if (req.headers.get("Content-Type") === "application/json" && req.status !== 204) {
      responseBody = await req.json();
    } else {
      responseBody = {};
    }

    return {
      body: responseBody,
      status: req.status,
      ok
    };
  } catch (err) {
    throw err;
    // return { body: undefined, status: 500, ok: false };
  }
}

const {
  INPUT_TWILIO_API_KEY,
  INPUT_TWILIO_API_SECRET,
  INPUT_TASKROUTER,
  INPUT_SYNC,
  INPUT_STUDIO,
  INPUT_SERVERLESS,
  INPUT_FLEX_CUSTOM_PLUGINS,
  GITHUB_OUTPUT,
} = process.env;

if (!INPUT_TWILIO_API_KEY?.trim()) {
  throw new Error("Missing Input TWILIO_API_KEY");
}
if (!INPUT_TWILIO_API_SECRET?.trim()) {
  throw new Error("Missing Input TWILIO_API_SECRET");
}

const DEFAULTS = {
  taskrouter: {
    Activities: [
      {
        FriendlyName: "Offline",
        Available: false
      },
      {
        FriendlyName: "Available",
        Available: true
      },
      {
        FriendlyName: "Unavailable",
        Available: false
      },
      {
        FriendlyName: "Break",
        Available: false
      }
    ],
    TaskChannels: [
      {
        FriendlyName: "Default",
        UniqueName: "default"
      },
      {
        FriendlyName: "Voice",
        UniqueName: "voice"
      },
      {
        FriendlyName: "Chat",
        UniqueName: "chat"
      }, 
      {
        FriendlyName: "SMS",
        UniqueName: "sms"
      },
      {
        FriendlyName: "Video",
        UniqueName: "video"
      }, 
      {
        FriendlyName: "Email",
        UniqueName: "email"
      }
    ],
    TaskQueues: [
      {
        FriendlyName: "Everyone",
        ReservationActivitySid: "Reserved for Task",
        AssignmentActivitySid: "Unavailable For Assignment",
        MaximumReservedWorkers: 1,
        TargetWorkers: "1==1",
        TaskOrder: "FIFO"
      }
    ],
    Workflows: [
      {
        FriendlyName: "Assign To Anyone",
        TaskReservationTimeout: 120,
        AssignmentCallbackUrl: "",
        FallbackAssignmentCallbackUrl: "",
        Configuration: {
          task_routing: {
            filters: [],
            default_filter: {
              queue: "<Everyone Queue Sid>"
            }
          }
        }
      }
    ]
  },
  sync: {
    Services: [
      {
        FriendlyName: "Default Service",
        UniqueName: "default",
        AclEnabled: false,
        ReachabilityEnabled: false,
        WebhookUrl: ""
      }
    ]
  },
  serverless: {
    Services: [
      {
        FriendlyName: "Flex Plugins Service (Autogenerated) - Do Not Delete",
        UniqueName: "default"
      }
    ]
  }
}

/**
 * @typedef Options
 * @property {boolean} skipCreate
 * @property {boolean} skipUpdate
 * @property {boolean} skipDelete
 * 
 * @param {string} baseUrl 
 * @param {string} resourceType 
 * @param {array.<Object>} defaults
 * @param {Options} options
 */
const listDeleteUpdateCreate = async (baseUrl, resourceType, defaults, options = null) => {
  const listResp = await asyncTwilioRequest(`${baseUrl}/${resourceType}`, "GET");
  /** @type {array} */
  const list = listResp.body[listResp.body.meta.key];

  if (!options?.skipDelete) {
    const toDelete = list
      .filter((item) => !defaults.some((def) => item.unique_name === def.UniqueName || item.friendly_name === def.FriendlyName))
      .map((item) => asyncTwilioRequest(`${baseUrl}/${resourceType}/${item.sid}`, "DELETE"));
    await Promise.all(toDelete);
  }
  
  if (!options?.skipUpdate) {
    const toUpdate = defaults
      .map((def) => [list.find((item) => item.unique_name === def.UniqueName || item.friendly_name === def.FriendlyName), def])
      .filter(([item]) => item !== undefined)
      .map(([item, def]) => {
        if (def.UniqueName) {
          delete def.UniqueName;
        }
        return asyncTwilioRequest(`${baseUrl}/${resourceType}/${item.sid}`, "POST", new URLSearchParams(def));
      });
    await Promise.all(toUpdate);
  }

  if (!options.skipCreate) {
    const toCreate = defaults
      .filter((def) => !list.some((item) => item.unique_name === def.UniqueName || item.friendly_name === def.FriendlyName))
      .map((def) => asyncTwilioRequest(`${baseUrl}/${resourceType}`, "POST", new URLSearchParams(def)));
    await Promise.all(toCreate);
  }
}

const getTrEveryoneQueueSid = async (workspaceUrl) => {
  const queueResponse = await asyncTwilioRequest(`${workspaceUrl}/TaskQueues`, "GET");
  /** @type {array} */
  const queues = queueResponse.body.task_queues;
  return queues.find((q) => q.friendly_name === "Everyone")?.sid;
}

const run = async () => {
  if (INPUT_TASKROUTER?.trim() === "true") {
    const workspaceResponse = await asyncTwilioRequest("https://taskrouter.twilio.com/v1/Workspaces", "GET");
    const workspaceSid = workspaceResponse.body.workspaces[0].sid;
    const workspaceUrl = `https://taskrouter.twilio.com/v1/Workspaces/${workspaceSid}`;

    let everyoneQueueSid = await getTrEveryoneQueueSid(workspaceUrl);

    await listDeleteUpdateCreate(workspaceUrl, "Tasks", [], { skipCreate: true, skipUpdate: true });
    await listDeleteUpdateCreate(workspaceUrl, "Workers", [], { skipCreate: true, skipUpdate: true });

    if (everyoneQueueSid) {
      DEFAULTS.taskrouter.Workflows[0].Configuration.task_routing.default_filter.queue = everyoneQueueSid;
      await listDeleteUpdateCreate(workspaceUrl, "Workflows", DEFAULTS.taskrouter.Workflows); 
    } else {
      // Everyone Queue doesn't exist yet, just delete all workflows for now
      await listDeleteUpdateCreate(workspaceUrl, "Workflows", [], { skipCreate: true, skipUpdate: true }); 
    }

    await listDeleteUpdateCreate(workspaceUrl, "TaskQueues", DEFAULTS.taskrouter.TaskQueues);
    
    if (!everyoneQueueSid) {
      // Create the default Workflow now that the Everyone queue exists
      everyoneQueueSid = await getTrEveryoneQueueSid(workspaceUrl);
      DEFAULTS.taskrouter.Workflows[0].Configuration.task_routing.default_filter.queue = everyoneQueueSid;
      await listDeleteUpdateCreate(workspaceUrl, "Workflows", DEFAULTS.taskrouter.Workflows);
    }

    await listDeleteUpdateCreate(workspaceUrl, "TaskChannels", DEFAULTS.taskrouter.TaskChannels);
    
    await listDeleteUpdateCreate(workspaceUrl, "Activities", DEFAULTS.taskrouter.Activities, { skipUpdate: true });
  }

  if (INPUT_SYNC?.trim() === "true") {
    await listDeleteUpdateCreate("https://sync.twilio.com/v1", "Services", DEFAULTS.sync.Services, { skipCreate: true });
    
    const servicesResp = await asyncTwilioRequest("https://sync.twilio.com/v1/Services", "GET");
    const services = servicesResp.body.services;
    if (services.some((s) => s.unique_name === "default")) {
      const defaultServiceUrl = "https://sync.twilio.com/v1/Services/default";
      await listDeleteUpdateCreate(defaultServiceUrl, "Documents", [], { skipCreate: true, skipUpdate: true });
      await listDeleteUpdateCreate(defaultServiceUrl, "Lists", [], { skipCreate: true, skipUpdate: true });
      await listDeleteUpdateCreate(defaultServiceUrl, "Maps", [], { skipCreate: true, skipUpdate: true });
      await listDeleteUpdateCreate(defaultServiceUrl, "Streams", [], { skipCreate: true, skipUpdate: true });
    }
  }

  if (INPUT_STUDIO?.trim() === "true") {
    await listDeleteUpdateCreate("https://studio.twilio.com/v2", "Flows", [], { skipCreate: true, skipUpdate: true });
  }

  if (INPUT_SERVERLESS?.trim() === "true") {
    await listDeleteUpdateCreate("https://serverless.twilio.com/v1", "Services", DEFAULTS.serverless.Services, { skipCreate: true, skipUpdate: true });
  }

  if (INPUT_FLEX_CUSTOM_PLUGINS?.trim() === "true") {
    const pluginConfigResp = await asyncTwilioRequest("https://flex-api.twilio.com/v1/PluginService/Configurations", "POST", new URLSearchParams({
      Name: "Disable All Custom Plugins"
    }));
    const configSid = pluginConfigResp.body.sid;

    await asyncTwilioRequest("https://flex-api.twilio.com/v1/PluginService/Releases", "POST", new URLSearchParams({
      ConfigurationId: configSid
    }));
  }
}
run();
